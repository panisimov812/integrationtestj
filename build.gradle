plugins {
    id 'java'
    id 'io.qameta.allure' version '3.0.2'
}

group = 'com.demoqa'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

// Версии из gradle.properties (для IDE и единого источника правды)
def junitVersion = findProperty('junitVersion') ?: '5.10.1'
def restAssuredVersion = findProperty('restAssuredVersion') ?: '5.4.0'
def allureVersion = findProperty('allureVersion') ?: '2.25.0'
def selenideVersion = '6.19.0'
def testngVersion = '7.9.0'
def testcontainersVersion = findProperty('testcontainersVersion') ?: '1.20.2'

dependencies {
    implementation "com.codeborne:selenide:${selenideVersion}"
    implementation 'org.slf4j:slf4j-simple:2.0.9'
    implementation "io.qameta.allure:allure-java-commons:${allureVersion}"
    implementation "com.fasterxml.jackson.core:jackson-databind:2.15.3"
    implementation "io.rest-assured:rest-assured:${restAssuredVersion}"
    implementation "io.rest-assured:json-path:${restAssuredVersion}"
    implementation "io.qameta.allure:allure-rest-assured:${allureVersion}"
    testImplementation "io.rest-assured:rest-assured:${restAssuredVersion}"
    testImplementation "io.rest-assured:json-path:${restAssuredVersion}"
    testImplementation "io.qameta.allure:allure-rest-assured:${allureVersion}"
    testImplementation "org.testng:testng:${testngVersion}"
    testImplementation "io.qameta.allure:allure-testng:${allureVersion}"
    testImplementation "io.qameta.allure:allure-selenide:${allureVersion}"
    // API tests: JUnit 5 (версия из gradle.properties; implementation — чтобы IDE разрешала импорты в src/test)
    implementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
    testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
    testImplementation "io.qameta.allure:allure-junit5:${allureVersion}"
    // Database testing: PostgreSQL + Testcontainers (pure JDBC, no Spring)
    implementation "org.postgresql:postgresql:42.7.2"
    implementation "org.testcontainers:testcontainers:${testcontainersVersion}"
    implementation "org.testcontainers:postgresql:${testcontainersVersion}"
    testImplementation "org.testcontainers:testcontainers:${testcontainersVersion}"
    testImplementation "org.testcontainers:junit-jupiter:${testcontainersVersion}"
    testImplementation "org.testcontainers:postgresql:${testcontainersVersion}"
}

// Задача test только запускает тесты; Allure-отчёт не генерируется и не открывается.
// Для отчёта: ./gradlew allureReport или ./gradlew allureServe
test {
    useTestNG() {
        suites 'src/test/resources/testng.xml'
    }
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// API-тесты на JUnit 5 + Rest Assured (отдельная задача)
tasks.register("apiTest", Test) {
    description = "Runs API tests (JUnit 5 + Rest Assured)"
    group = "verification"
    useJUnitPlatform()
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    include "**/api/*Test.class", "**/api/*ApiTest.class"
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// DB-тесты: PostgreSQL + Testcontainers, чистый JDBC
tasks.register("dbTest", Test) {
    description = "Runs database integration tests (JUnit 5 + Testcontainers + JDBC)"
    group = "verification"
    useJUnitPlatform()
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    include "**/db/*Test.class", "**/db/*DbTest.class"
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// Запуск всех тестов одной командой: UI (TestNG) + API (JUnit) + DB (JUnit)
tasks.register("allTests") {
    description = "Runs all tests: UI, API, and Database"
    group = "verification"
    dependsOn test, apiTest, dbTest
}

allure {
    version = allureVersion
    autoconfigure = true
}

// Генерация Allure-отчёта после тестов; allureServe подтянет отчёт и откроет в браузере
// Для Allure-отчёта по API-тестам: ./gradlew apiTest allureReport allureServe
tasks.named("allureReport") {
    dependsOn(test, apiTest, dbTest)
    // Очищаем каталог отчёта, чтобы не было ошибки "directory is already in use"
    doFirst {
        def reportTaskDir = layout.buildDirectory.dir("reports/allure-report/allureReport").get().asFile
        if (reportTaskDir.exists()) {
            delete reportTaskDir
        }
    }
}
tasks.named("allureServe") {
    dependsOn(allureReport)
}

// Чтобы отчёт всегда появлялся даже при падении тестов: при запуске allureReport/allureServe
// не останавливаем сборку из-за провала test (отчёт сгенерируется и откроется)
gradle.taskGraph.whenReady { graph ->
    if (graph.hasTask(":allureReport") || graph.hasTask(":allureServe")) {
        tasks.named("test").configure { ignoreFailures = true }
        tasks.named("apiTest").configure { ignoreFailures = true }
        tasks.named("dbTest").configure { ignoreFailures = true }
    }
}

// Открыть отчёт в браузере вручную (если allureServe не открыл автоматически)
tasks.register("openAllureReport") {
    dependsOn(allureReport)
    doLast {
        def reportDir = layout.buildDirectory.dir("reports/allure-report").get().asFile
        def indexHtml = new File(reportDir, "index.html")
        if (indexHtml.exists()) {
            def uri = indexHtml.toURI()
            if (uri.scheme == "file" && java.awt.Desktop.isDesktopSupported()) {
                try {
                    java.awt.Desktop.desktop.browse(uri)
                    println "Отчёт открыт: ${uri}"
                } catch (Exception e) {
                    println "Не удалось открыть браузер. Откройте вручную: ${indexHtml.absolutePath}"
                }
            } else {
                println "Откройте вручную: ${indexHtml.absolutePath}"
            }
        } else {
            println "Сначала выполните: ./gradlew allureReport"
        }
    }
}
